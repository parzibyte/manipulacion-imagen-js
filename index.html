<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div class="flex flex-col p-1 items-center">
        <h1 class="text-xl">Imágenes en blanco y negro, escala de grises y dithering</h1>
        <div class="bg-green-500 text-white p-2 rounded-md mt-2">Con esta herramienta podrás convertir una
            imagen de color a una imagen de color a escala de grises, blanco y negro o blanco y negro con dithering para
            mejorar sus detalles visuales incluso cuando solo uses b/n</div>
        <input
            class="my-2 hover:file:text-white hover:file:bg-green-500 hover:cursor-pointer max-w-min file:border file:border-green-200 file:text-green-500 file:rounded-md file:p-2 p-1 border-green-200 border-2 rounded-md text-green-400"
            type="file" id="imagen" accept="image/jpeg,image/png,image/avif,image/webp">
        <canvas class="rounded-md max-w-64 w-full" id="original"></canvas>
        <select
            class="ocultable focus:outline-none focus:text-white focus:bg-green-500 hover:text-white hover:bg-green-500 max-w-min hover:cursor-pointer border border-green-200 rounded-md text-green-500 p-2 my-2"
            name="color" id="color">
            <option value="grises">Escala de grises</option>
            <option value="bn">Blanco y negro</option>
            <option value="bndithering">Blanco y negro con dithering</option>
        </select>
        <canvas class="ocultable rounded-md max-w-64 w-full" id="resultado"></canvas>
        <div class="ocultable bg-green-500 text-white p-2 rounded-md text-xs mt-2">La imagen no se muestra en tamaño completo para
            no
            romper el diseño. <br> Para ver la imagen en su calidad original debes descargarla</div>
        <select
            class="ocultable focus:outline-none focus:text-white focus:bg-green-500 hover:text-white hover:bg-green-500 max-w-min hover:cursor-pointer border border-green-200 rounded-md text-green-500 p-2 my-2"
            name="formato" id="formato">
            <option value="image/png">PNG</option>
            <option value="image/jpeg">JPEG</option>
            <option value="image/avif">AVIF</option>
            <option value="image/webp">WEBP</option>
        </select>
        <button id="descargar"
            class="ocultable mt-2 focus:outline-none focus:text-white focus:bg-green-500  border border-green-200 text-green-500 max-w-min rounded p-2 hover:text-white hover:bg-green-500 hover:cursor-pointer">Descargar</button>
    </div>

    <script>


        const convertirIndiceDePixelACoordenadas = (indice, ancho) => {
            const pixel = indice / 4;
            const x = pixel % ancho;
            const y = Math.floor(pixel / ancho);
            return [x, y];
        }

        const convertirCoordenadasAIndice = (x, y, ancho) => {
            return (y * ancho + x) * 4; // 4 es la cantidad de niveles por pixel
        }

        const calcular716 = (pixelesEscalaGrises, indice, errorDeCuantificacion) => {
            return pixelesEscalaGrises[indice] + errorDeCuantificacion * 7 / 16;
        }

        const establecerNivelDeColorEnImagen = (pixelesEscalaGrises, x, y, nuevoValor) => {
            const indice = convertirCoordenadasAIndice(x, y);
            if (indice > pixelesEscalaGrises.length) {
                return pixelesEscalaGrises;
            }
            pixelesEscalaGrises[indice] = nuevoValor;
            pixelesEscalaGrises[indice + 1] = nuevoValor;
            pixelesEscalaGrises[indice + 2] = nuevoValor;
            return pixelesEscalaGrises;
        }
        const propagarError = (pixelesEscalaGrises, indice, errorDeCuantificacion, ancho, alto) => {
            /*
                    pixels[x + 1][y    ] := pixels[x + 1][y    ] + quant_error × 7 / 16
                    pixels[x - 1][y + 1] := pixels[x - 1][y + 1] + quant_error × 3 / 16
                    pixels[x    ][y + 1] := pixels[x    ][y + 1] + quant_error × 5 / 16
                    pixels[x + 1][y + 1] := pixels[x + 1][y + 1] + quant_error × 1 / 16
                */
            const nivelesPorPixel = 4;

            //pixels[x + 1][y    ] := pixels[x + 1][y    ] + quant_error × 7 / 16
            const [x, y] = convertirIndiceDePixelACoordenadas(indice, ancho);
            if (x < ancho - 1) {
                for (let i = 0; i < 3; i++) {
                    pixelesEscalaGrises[indice + nivelesPorPixel + i] += errorDeCuantificacion * 7 / 16
                }
            }

            //pixels[x - 1][y + 1] := pixels[x - 1][y + 1] + quant_error × 3 / 16
            if (x > 0) {
                for (let i = 0; i < 3; i++) {
                    pixelesEscalaGrises[indice - nivelesPorPixel + (ancho * nivelesPorPixel) + i] += errorDeCuantificacion * 3 / 16
                }
            }
            //pixels[x    ][y + 1] := pixels[x    ][y + 1] + quant_error × 5 / 16
            if (y < alto - 1) {
                for (let i = 0; i < 3; i++) {
                    pixelesEscalaGrises[indice + (ancho * nivelesPorPixel) + i] += errorDeCuantificacion * 5 / 16
                }
            }

            //pixels[x + 1][y + 1] := pixels[x + 1][y + 1] + quant_error × 1 / 16
            if (y < alto - 1 && x < ancho - 1) {
                for (let i = 0; i < 3; i++) {
                    pixelesEscalaGrises[indice + (ancho * nivelesPorPixel) + nivelesPorPixel + i] += errorDeCuantificacion * 1 / 16
                }
            }

        }
        const modificarBN = (pixeles) => {
            const posicionesPorPixel = 4;
            for (let indice = 0; indice < pixeles.length; indice += posicionesPorPixel) {
                // Hasta este punto los niveles RGB ya están igualados y da igual a cuál de ellos accedamos, todos tienen el mismo nivel de gris
                const gris = pixeles[indice];
                const alfa = pixeles[indice + 3];
                if (gris > 128) {
                    // Todo es blanco
                    pixeles[indice] = 255;
                    pixeles[indice + 1] = 255;
                    pixeles[indice + 2] = 255;
                } else {
                    if (alfa < 128) {
                        // Todo es blanco
                        pixeles[indice] = 255;
                        pixeles[indice + 1] = 255;
                        pixeles[indice + 2] = 255;
                    } else {
                        // Todo es negro
                        pixeles[indice] = 0;
                        pixeles[indice + 1] = 0;
                        pixeles[indice + 2] = 0;
                    }
                }
                //console.log(`rgba(${rojo}, ${verde}, ${azul}, ${alpha})`);
            }
            return pixeles;
        }
        const modificarParaEscalaDeGrises = (pixeles) => {
            const posicionesPorPixel = 4;
            for (let indice = 0; indice < pixeles.length; indice += posicionesPorPixel) {
                const rojo = pixeles[indice];
                const verde = pixeles[indice + 1];
                const azul = pixeles[indice + 2];
                const gris = 0.3 * rojo + 0.59 * verde + 0.11 * azul;
                pixeles[indice] = gris;
                pixeles[indice + 1] = gris;
                pixeles[indice + 2] = gris;
            }
            return pixeles;
        }
        const modificarParaDithering = (pixelesEscalaGrises, ancho, alto) => {

            for (let indice = 0; indice < pixelesEscalaGrises.length; indice += 4) {
                // Hasta este punto los niveles RGB ya están igualados y da igual a cuál de ellos accedamos, todos tienen el mismo nivel de gris
                const gris = pixelesEscalaGrises[indice];
                const alfa = pixelesEscalaGrises[indice + 3];
                let nivel = 255;
                if (gris < 128 && alfa > 128) {
                    nivel = 0;
                }
                pixelesEscalaGrises[indice] = nivel;
                pixelesEscalaGrises[indice + 1] = nivel;
                pixelesEscalaGrises[indice + 2] = nivel;
                const errorDeCuantificacion = gris - nivel;
                //console.log("nivel de gris %o error cuantificación %o", gris, errorDeCuantificacion);
                propagarError(pixelesEscalaGrises, indice, errorDeCuantificacion, ancho, alto)
                //console.log(`rgba(${rojo}, ${verde}, ${azul}, ${alpha})`);
            }
            return pixelesEscalaGrises;
        }
        document.addEventListener("DOMContentLoaded", async () => {

            const $imagen = document.querySelector("#imagen");
            const $canvasResultado = document.querySelector("#resultado");
            const $color = document.querySelector("#color");
            const $original = document.querySelector("#original");
            const $descargar = document.querySelector("#descargar");
            const $formato = document.querySelector("#formato");

            document.querySelectorAll(".ocultable").forEach(elemento => elemento.style.visibility = "hidden");
            const pintarImagenOriginal = (imagenComoBitmap) => {
                $original.width = imagenComoBitmap.width;
                $original.height = imagenComoBitmap.height;
                const contexto = $original.getContext("2d");
                contexto.drawImage(imagenComoBitmap, 0, 0);
            }

            const generarImagenSegunOpcionesElegidas = async () => {
                const archivos = $imagen.files;
                if (archivos.length <= 0) {
                    return;
                }
                const imagen = archivos[0];
                const imagenComoBitmap = await createImageBitmap(imagen);
                pintarImagenOriginal(imagenComoBitmap);
                $canvasResultado.width = imagenComoBitmap.width;
                $canvasResultado.height = imagenComoBitmap.height;
                const contexto = $canvasResultado.getContext("2d");
                contexto.drawImage(imagenComoBitmap, 0, 0);
                const imageData = contexto.getImageData(0, 0, imagenComoBitmap.width, imagenComoBitmap.height);
                let pixeless = [];
                if ($color.value === "grises") {
                    pixeless = modificarParaEscalaDeGrises(imageData.data);
                } else if ($color.value === "bn") {
                    pixeless = modificarBN(imageData.data);
                } else if ($color.value === "bndithering") {
                    // Dithering necesita que ya esté en escala de grises
                    pixeless = modificarParaDithering(modificarParaEscalaDeGrises(imageData.data), imagenComoBitmap.width, imagenComoBitmap.height);
                }
                contexto.putImageData(new ImageData(pixeless, imagenComoBitmap.width, imagenComoBitmap.height), 0, 0);
            }
            $imagen.onchange = () => {
                document.querySelectorAll(".ocultable").forEach(elemento => elemento.style.visibility = "visible");
                generarImagenSegunOpcionesElegidas()
            }
            $color.onchange = generarImagenSegunOpcionesElegidas;

            const obtenerNombreParaDescargar = () => {
                if ($imagen.files.length <= 0) {
                    return "";
                }
                const nombre = $imagen.files[0].name;
                const nombreSinExtension = nombre.substring(0, nombre.lastIndexOf("."));
                let extension = "";
                if ($formato.value === "image/jpeg") {
                    extension = "jpg";
                } else {
                    extension = $formato.value.substring($formato.value.indexOf("/") + 1)
                }
                return nombreSinExtension + "_" + $color.value + "." + extension;
            }

            $descargar.onclick = () => {
                let enlace = document.createElement('a');
                // El título
                enlace.download = obtenerNombreParaDescargar();
                // Convertir la imagen a Base64 y ponerlo en el enlace
                enlace.href = $canvasResultado.toDataURL($formato.value, 1);
                // Hacer click en él
                enlace.click();
            }
        })
    </script>
</body>

</html>